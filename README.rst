********************************
Auto Binary Classification (ABC)
********************************


Мотивация:
----------
Существует много различных библиотек для создания моделей машинного обучения. Хочется иметь один интерфейс работы с ними, ведь в данной библиотеке в теории нужно использовать большинство из них. Поэтому библиотека основана на абстрации *Pipe*, котороая позваоляет иметь одинаковых интерефейс для работы с различными моделямя: все они обучаются и делают предсказания. К примеру, у *sklearn* существуют свои пайплайны, но они позволяют работать в основном только со своей библиотекой.

Как все работает:
-----------------

Данная библиотека предназначена для подбора лучшей модели бинарной классификации. Так как структура напоминает *зверниц*, то в названиях используется слова *zoo* и *animal*. Пример использования:

.. code-block:: python

    my_auto_ml = AutoML()

    my_auto_ml.fit_all_animals(X, y)
    best_animal = my_auto_ml.get_best_animal()
    best_animal.predict(X_test)

Под капотом в библиотеке хранится набор моделей (пайплайнов), которые обучаются и из которых мы выбираем.

Структрура библиотеки:
----------------------
 - ABC
    - core
        - storage - отвечает за сохранения и загрузку, использует cloudpickle, так как не все объекты сохраняются с помощью встроенного pickle
        - auto - отвечает за загрзку *зверинца* моделей и их обучение. На данный момент используются всего несколько моделей, логика которых написана в *ABC.zoo.animals*, далее все обучаются и выбирается лучшая. Но если моделей будет много, можно брать произвольно или делать модели второго уровня - библиотека это позволяет
        - model, transform - два абстрактных класса, которые задают макет *Моделей* и *Трансформаций* над данными
        - pipe - обертка на *model* и *transform*
        - metric - отвечает за оценку модели (обертка)
    - zoo
        - model (optimize) - набор уже имплементированных моделей
        - transform - набор преобразователей данных (к примеру различные скейлеры или какое то добавление фичей можно делать тут)
        - animals - набор *Моделей*, а точнее пайплайнов, которые могу обучаться и предсказывать

Добавление моделей из которых выбирает библиотека:
--------------------------------------------------

**AutoML** из данной библиотеки (*ABC.core.auto.AutoML*) обучает и оцениваев пайплайны, заранее заготовленные и хранящиеся в *ABC.zoo.animals*. Пример такого пайплайна:

.. code-block:: python

   my_pipe = Pipe([
        ModelCrossValidation(),
        GridOptimizeMaxDepth(),
        GridOptimizeMinChildWeight(),
        ModelXGB()
    ])

Далее нам нужно его обучить. Делается это просто:

.. code-block:: python

    X_data = Data(train=X_train)
    y_data = Data(train=y_train)

    my_pipe.fit(X_data, y_data)

Далее наш пайплайн обучен и мы можем сделать предсказание:

.. code-block:: python

    my_pipe.fit(X_test)

Чтобы удобнее было работать с оценкой модели, существует класс *MetricEvaluator*:

.. code-block:: python

    my_pipe.fit(X_data, y_data)
    pipe_me = MetricEvaluator(model=my_pipe, X_test=X_test, y_test=y_test)

    pipe_me.get_report()
    pipe_me.get_precision_score()
    pipe_me.get_f1_score()
    ...

Как видно, каждый пайплайн состоит из *кубиков*, каждый такой *кубик* наследуюется от *AbstractModel* или *AbstractTransform*. Рассмотрим пример:

.. code-block:: python

    class ModelSVC(AbstractModel):
        __name__ = 'ModelSVC'

        def __init__(self,):
            super().__init__()
            self.params = dict(kernel='linear')
            self.son = None

        def fit(self, son: Pipe, X: Data, y: Data, params: dict):
            params = params if params else {}

            self.params.update(params)
            clf = SVC(**self.params)
            clf.fit(X.train, y.train)
            self.model = clf

        def predict(self, X):
            prediction = self.model.predict(X)
            return prediction

Для того, чтобы сделать такой *кубик*, нам нужно отнаследоваться от *AbstractModel* или *AbstractTransform*, и реализовать в простом случае два методы: *fit* и *predict*.

Далее мы можем сделать новый пайплайн, используя наш новый *кубик*.

Pipe:
-----

*Pipe* работает таким образом, что каждый объект хранит указатель на своего потомка. Когда к нему применятеся *fit*, то данные проходят сквозь все объекты в нем, позволяя каждому объекту обучиться или преобразовать данные и отправить их дальше. Так же плюс в том, что мы можем сохранить его весь и после загрузки полность восстановим последовательность действий.

Что можно улучшить:
-------------------
 - Более консистетно использовать *Модели*, *Трансформы* и *Оптимизаторы*. К примеру, все они принимают в метод *fit* объекты *Data*, а метод *predict* уже пандосовский датафрейм
 - Сделать сохранение данных в более комактный вид (numpy array, h5)
 - Сохранять нативными средствами, такими как joblib (Scikit) и save_model (CatBoost) и т.д.
 - ModelCrossValidation усредняет предсказания голосованием, что является не лучшей идеей и стоит усреднять веротности
 - Скорее всего достатно багов, так что нужно тестировать
 - Много еще всего

Примеры:
--------

Чтобы лучше понять как все рабоатет и посмотреть на примеры, зайдите в папку *notebooks*.